/*
 * Copyright 2020 eBlocker Open Source UG (haftungsbeschraenkt)
 *
 * Licensed under the EUPL, Version 1.2 or - as soon they will be
 * approved by the European Commission - subsequent versions of the EUPL
 * (the "License"); You may not use this work except in compliance with
 * the License. You may obtain a copy of the License at:
 *
 *   https://joinup.ec.europa.eu/page/eupl-text-11-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.eblocker.server.icap.transaction.processor;

import org.eblocker.server.common.data.Device;
import org.eblocker.server.common.session.Session;
import org.eblocker.server.common.transaction.TransactionContext;
import org.eblocker.server.http.service.DeviceService;
import org.eblocker.server.icap.filter.Category;
import org.eblocker.server.icap.filter.Filter;
import org.eblocker.server.icap.filter.FilterManager;
import org.eblocker.server.icap.filter.FilterResult;
import org.eblocker.server.icap.transaction.Transaction;
import org.eblocker.server.icap.transaction.processor.filter.PatternBlockerUtils;
import org.eblocker.server.common.network.BaseURLs;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class MalwarePatternFilterProcessorTest {

    private static final String REDIRECT_PAGE = "malware-detected.html";
    private static final String BLOCKED_URL = "https://malware.org/latest.exe";
    private static final String BASE_URL = "https://eblocker.box/";

    private Device device;
    private Session session;
    private Transaction transaction;
    private Filter filter;
    private FilterManager filterManager;
    private MalwarePatternFilterProcessor processor;
    private PatternBlockerUtils patternBlockerUtils;

    @Before
    public void setUp() {
        device = Mockito.mock(Device.class);
        DeviceService deviceService = Mockito.mock(DeviceService.class);
        Mockito.when(deviceService.getDeviceById(Mockito.anyString())).thenReturn(device);

        session = Mockito.mock(Session.class);
        Mockito.when(session.getDeviceId()).thenReturn("device:1234");

        transaction = Mockito.mock(Transaction.class, Mockito.RETURNS_DEEP_STUBS);
        Mockito.when(transaction.getSession()).thenReturn(session);

        BaseURLs baseUrls = Mockito.mock(BaseURLs.class);
        Mockito.when(baseUrls.selectURLForPage(Mockito.any())).thenReturn(BASE_URL);

        filter = Mockito.mock(Filter.class);
        filterManager = Mockito.mock(FilterManager.class);
        Mockito.when(filterManager.getFilter(Category.MALWARE)).thenReturn(filter);

        patternBlockerUtils = Mockito.mock(PatternBlockerUtils.class);

        processor = new MalwarePatternFilterProcessor(REDIRECT_PAGE, baseUrls, deviceService, filterManager, patternBlockerUtils);
    }

    @Test
    public void testMalwareFilterDisabled() {
        Mockito.when(device.isMalwareFilterEnabled()).thenReturn(false);
        Assert.assertTrue(processor.process(transaction));
        Mockito.verifyZeroInteractions(filterManager);
    }

    @Test
    public void testMalwareFilterNoDecision() {
        Mockito.when(device.isMalwareFilterEnabled()).thenReturn(true);
        Mockito.when(filter.filter(Mockito.any(TransactionContext.class))).thenReturn(FilterResult.NO_DECISION);
        Assert.assertTrue(processor.process(transaction));
        Mockito.verify(filter).filter(transaction);
        Mockito.verifyZeroInteractions(patternBlockerUtils);
    }

    @Test
    public void testMalwareFilterBlock() throws UnsupportedEncodingException {
        Mockito.when(device.isMalwareFilterEnabled()).thenReturn(true);
        FilterResult result = FilterResult.block(filter);
        Mockito.when(filter.filter(Mockito.any(TransactionContext.class))).thenReturn(result);
        Mockito.when(transaction.getRequest().uri()).thenReturn(BLOCKED_URL);

        Assert.assertFalse(processor.process(transaction));
        Mockito.verify(filter).filter(transaction);
        Mockito.verify(transaction).redirect(BASE_URL + REDIRECT_PAGE + "?target=" + URLEncoder.encode(BLOCKED_URL, "UTF-8"));
        Mockito.verify(patternBlockerUtils).countBlockedDomain(org.eblocker.server.common.data.parentalcontrol.Category.MALWARE, result, session, transaction);
    }
}
