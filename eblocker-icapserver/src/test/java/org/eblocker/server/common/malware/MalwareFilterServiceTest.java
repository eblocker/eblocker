/*
 * Copyright 2020 eBlocker Open Source UG (haftungsbeschraenkt)
 *
 * Licensed under the EUPL, Version 1.2 or - as soon they will be
 * approved by the European Commission - subsequent versions of the EUPL
 * (the "License"); You may not use this work except in compliance with
 * the License. You may obtain a copy of the License at:
 *
 *   https://joinup.ec.europa.eu/page/eupl-text-11-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.eblocker.server.common.malware;

import org.eblocker.server.common.data.DataSource;
import org.eblocker.server.common.network.unix.IpSetConfig;
import org.eblocker.server.common.network.unix.IpSets;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class MalwareFilterServiceTest {

    private Path malwareUrlListPath;
    private Path malwareIpListPath;
    private IpSetConfig ipSetConfig;
    private DataSource dataSource;
    private IpSets ipSets;
    private ObjectMapper objectMapper;
    private List<MalwareEntry> entries;
    private Map<String, List<Integer>> ipPortEntries;

    @Before
    public void setup() throws IOException {
        malwareUrlListPath = Files.createTempFile("malware-urls", ".json");
        malwareIpListPath = Files.createTempFile("malware-ip-ports", ".json");

        dataSource = Mockito.mock(DataSource.class);
        Mockito.when(dataSource.isMalwareUrlFilterEnabled()).thenReturn(true);

        objectMapper = Mockito.mock(ObjectMapper.class);
        entries = new ArrayList<>();
        entries.add(new MalwareEntry("perso.wanadoo.es/voxcard_01", new String[] { "unit-test" }));
        entries.add(new MalwareEntry("perso.wanadoo.es/kamasu", new String[] { "unit-test-2" }));
        entries.add(new MalwareEntry("11300.url.9xiazaiqi.com/down", new String[] { "Variant.Symmi.70519", "Variant.Application.Downloader", "Variant.Zusy.236047", "Downloader.Win32.Snojan.vuf", "Downloader.Win32.Snojan.awmu" }));
        Mockito.doReturn(entries).when(objectMapper).readValue(Mockito.<File>argThat(file -> file.getPath().equals(malwareUrlListPath.toString())), Mockito.any(TypeReference.class));

        ipPortEntries = new HashMap<>();
        ipPortEntries.put("95.141.193.66", Collections.singletonList(8083));
        ipPortEntries.put("218.95.37.205", Arrays.asList(8055,8010));
        Mockito.doReturn(ipPortEntries).when(objectMapper).readValue(Mockito.<File>argThat(file -> file.getPath().equals(malwareIpListPath.toString())), Mockito.any(TypeReference.class));

        ipSetConfig = new IpSetConfig("unit-test", "hash:ip,port", 65536);
        ipSets = Mockito.mock(IpSets.class);
        Mockito.when(ipSets.isSupportedByOperatingSystem()).thenReturn(true);
    }

    @After
    public void tearDown() throws IOException {
        Files.deleteIfExists(malwareUrlListPath);
    }

    @Test
    public void testInitWithIpSetSupport() throws IOException {
        Mockito.when(ipSets.isSupportedByOperatingSystem()).thenReturn(true);

        MalwareFilterService filterService = createService();
        filterService.init();
        Mockito.verify(ipSets).createIpSet(ipSetConfig);
    }

    @Test
    public void testInitWithoutIpSetSupport() throws IOException {
        Mockito.when(ipSets.isSupportedByOperatingSystem()).thenReturn(false);

        MalwareFilterService filterService = createService();
        filterService.init();
        Mockito.verify(ipSets, Mockito.never()).createIpSet(Mockito.any());
    }

    @Test
    public void testInitDisabled() throws IOException {
        Mockito.when(dataSource.isMalwareUrlFilterEnabled()).thenReturn(false);

        MalwareFilterService filterService = createService();
        filterService.init();
        Assert.assertFalse(filterService.isBlocked("perso.wanadoo.es/voxcard_01"));
        Mockito.verify(ipSets).updateIpSet(ipSetConfig, Collections.emptySet());
    }

    @Test
    public void testIsBlocked() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertFalse(filterService.isBlocked("http://xkcd.org"));
        Assert.assertFalse(filterService.isBlocked("https://xkcd.org"));
        Assert.assertFalse(filterService.isBlocked("http://xkcd.com/1865/"));
        Assert.assertFalse(filterService.isBlocked("https://xkcd.com/1865/"));
        Assert.assertFalse(filterService.isBlocked("kcd.com/1865"));
        Assert.assertFalse(filterService.isBlocked("xkcd.com/1865"));
        Assert.assertTrue(filterService.isBlocked("perso.wanadoo.es/voxcard_01"));
        Assert.assertTrue(filterService.isBlocked("perso.wanadoo.es/voxcard_01"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/voxcard_01"));
        Assert.assertTrue(filterService.isBlocked("https://perso.wanadoo.es/voxcard_01"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/voxcard_01/"));
        Assert.assertTrue(filterService.isBlocked("https://perso.wanadoo.es/voxcard_01/"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/kamasu"));
        Assert.assertTrue(filterService.isBlocked("https://perso.wanadoo.es/kamasu"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/kamasu/random/sub/path"));
        Assert.assertTrue(filterService.isBlocked("https://perso.wanadoo.es/kamasu/random/sub/path"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/kamasu/file.html"));
        Assert.assertTrue(filterService.isBlocked("https://perso.wanadoo.es/kamasu/file.html"));
    }

    @Test
    public void testGetMalwareByUrl() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertNotNull(filterService.getMalwareByUrl("http://xkcd.org").isEmpty());
        Assert.assertTrue(filterService.getMalwareByUrl("http://xkcd.org").isEmpty());

        Assert.assertNotNull(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down"));
        Assert.assertFalse(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").isEmpty());
        Assert.assertEquals(5, filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").size());
        Assert.assertTrue(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").contains("Variant.Symmi.70519"));
        Assert.assertTrue(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").contains("Variant.Application.Downloader"));
        Assert.assertTrue(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").contains("Variant.Zusy.236047"));
        Assert.assertTrue(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").contains("Downloader.Win32.Snojan.vuf"));
        Assert.assertTrue(filterService.getMalwareByUrl("http://11300.url.9xiazaiqi.com/down").contains("Downloader.Win32.Snojan.awmu"));
    }

    @Test
    public void testCheckUpdate() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertFalse(filterService.isBlocked("http://www.microsoft.com"));

        entries.add(new MalwareEntry("www.microsoft.com", new String[] { "win10.spyware" }));
        Files.setLastModifiedTime(malwareUrlListPath, FileTime.from(Instant.now().plus(2, ChronoUnit.SECONDS))); // filesystem's time precision may be too low to detect change otherwise
        filterService.checkUpdate();

        Assert.assertTrue(filterService.isBlocked("http://www.microsoft.com"));
    }

    @Test
    public void testCheckUpdateIps() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        ArgumentCaptor<Set<String>> entries = ArgumentCaptor.forClass(Set.class);
        Mockito.verify(ipSets).updateIpSet(Mockito.eq(ipSetConfig), entries.capture());
        Assert.assertEquals(3, entries.getValue().size());
        Assert.assertTrue(entries.getValue().contains("95.141.193.66,tcp:8083"));
        Assert.assertTrue(entries.getValue().contains("218.95.37.205,tcp:8055"));
        Assert.assertTrue(entries.getValue().contains("218.95.37.205,tcp:8010"));

        ipPortEntries.clear();
        ipPortEntries.put("218.95.37.205", Collections.singletonList(8010));
        ipPortEntries.put("222.186.50.169", Collections.singletonList(8865));
        Files.setLastModifiedTime(malwareIpListPath, FileTime.from(Instant.now().plus(2, ChronoUnit.SECONDS))); // filesystem's time precision may be too low to detect change otherwise
        filterService.checkUpdate();

        Mockito.verify(ipSets, Mockito.times(2)).updateIpSet(Mockito.eq(ipSetConfig), entries.capture());
        Assert.assertEquals(2, entries.getValue().size());
        Assert.assertTrue(entries.getValue().contains("218.95.37.205,tcp:8010"));
        Assert.assertTrue(entries.getValue().contains("222.186.50.169,tcp:8865"));
    }

    @Test
    public void testCheckNoUpdate() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertFalse(filterService.isBlocked("http://www.microsoft.com"));

        entries.add(new MalwareEntry("www.microsoft.com", new String[] { "win10.spyware" }));
        FileTime unmodifiedFileTime = Files.getLastModifiedTime(malwareUrlListPath);
        Files.setLastModifiedTime(malwareUrlListPath, unmodifiedFileTime);
        filterService.checkUpdate();

        Assert.assertFalse(filterService.isBlocked("http://www.microsoft.com"));
    }

    @Test
    public void testCheckUpdateFailure() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertFalse(filterService.isBlocked("http://www.microsoft.com"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/voxcard_01"));

        Files.delete(malwareUrlListPath);
        filterService.checkUpdate();

        Assert.assertFalse(filterService.isBlocked("http://www.microsoft.com"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/voxcard_01"));

        entries.add(new MalwareEntry("www.microsoft.com", new String[] { "win10.spyware" }));
        Files.createFile(malwareUrlListPath);
        Files.setLastModifiedTime(malwareUrlListPath, FileTime.from(Instant.now().plus(2, ChronoUnit.SECONDS))); // filesystem's time precision may be too low to detect change otherwise
        filterService.checkUpdate();

        Assert.assertTrue(filterService.isBlocked("http://www.microsoft.com"));
        Assert.assertTrue(filterService.isBlocked("http://perso.wanadoo.es/voxcard_01"));
    }

    @Test
    public void testMissingMalwareList() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        MalwareFilterService service = new MalwareFilterService("no/such/file", "no/such/file", ipSetConfig, dataSource, ipSets, objectMapper);
        Assert.assertFalse(service.isBlocked("http://www.microsoft.com"));
    }

    @Test
    public void testIpSet() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        ArgumentCaptor<Set<String>> entries = ArgumentCaptor.forClass(Set.class);
        Mockito.verify(ipSets).updateIpSet(Mockito.eq(ipSetConfig), entries.capture());
        Assert.assertEquals(3, entries.getValue().size());
        Assert.assertTrue(entries.getValue().contains("95.141.193.66,tcp:8083"));
        Assert.assertTrue(entries.getValue().contains("218.95.37.205,tcp:8055"));
        Assert.assertTrue(entries.getValue().contains("218.95.37.205,tcp:8010"));
    }

    @Test
    public void testDisableEnableFilter() throws IOException {
        MalwareFilterService filterService = createService();
        filterService.init();

        Assert.assertTrue(filterService.isEnabled());

        // disable
        filterService.setEnabled(false);
        Assert.assertFalse(filterService.isEnabled());
        Assert.assertFalse(filterService.isBlocked("perso.wanadoo.es/voxcard_01"));
        Mockito.verify(dataSource).setMalwareUrlFilterEnabled(false);
        Mockito.verify(ipSets).updateIpSet(ipSetConfig, Collections.emptySet());

        // enable
        filterService.setEnabled(true);
        Assert.assertTrue(filterService.isEnabled());
        Assert.assertTrue(filterService.isBlocked("perso.wanadoo.es/voxcard_01"));
        Mockito.verify(dataSource).setMalwareUrlFilterEnabled(true);
        ArgumentCaptor<Set<String>> captor = ArgumentCaptor.forClass(Set.class);
        Mockito.verify(ipSets, Mockito.times(3)).updateIpSet(Mockito.eq(ipSetConfig), captor.capture());
        Assert.assertEquals(3, captor.getValue().size());
    }

    private MalwareFilterService createService() {
        return new MalwareFilterService(malwareUrlListPath.toString(), malwareIpListPath.toString(), ipSetConfig, dataSource, ipSets, objectMapper);
    }
}
